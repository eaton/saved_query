<?php

namespace Drupal\saved_query\Plugin\Field\FieldType;

use Drupal\Component\Utility\Random;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Field\FieldItemBase;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\Core\TypedData\DataDefinition;
use Drupal\Core\Entity\Query\QueryInterface;
use Drupal\Component\Serialization\Json;

/**
 * Plugin implementation of the 'saved_query_field' field type.
 *
 * @FieldType(
 *   id = "saved_query_field",
 *   label = @Translation("Saved Query"),
 *   description = @Translation("Stores information needed to run a saved database query"),
 *   default_widget = "raw_saved_query_widget",
 *   default_formatter = "preview_saved_query_formatter"
 * )
 */
class SavedQueryField extends FieldItemBase {

  /**
   * {@inheritdoc}
   */
  public static function defaultFieldSettings() {
    return [
      'target_field' => '',
    ] + parent::defaultFieldSettings();
  }

  /**
   * {@inheritdoc}
   */
  public static function propertyDefinitions(FieldStorageDefinitionInterface $field_definition) {
    // Prevent early t() calls by using the TranslatableMarkup.
    $properties['entity_type'] = DataDefinition::create('string')
      ->setLabel(new TranslatableMarkup('Entity Type'));

    $properties['raw_sorts'] = DataDefinition::create('string')
      ->setLabel(new TranslatableMarkup('Raw Sorts'));

    $properties['raw_conditions'] = DataDefinition::create('string')
      ->setLabel(new TranslatableMarkup('Raw Conditions'));

    $properties['limit'] = DataDefinition::create('integer')
      ->setLabel(new TranslatableMarkup('Result limit'));

    $properties['interval'] = DataDefinition::create('integer')
      ->setLabel(new TranslatableMarkup('Refresh Interval'));

    $properties['refreshed'] = DataDefinition::create('integer')
      ->setLabel(new TranslatableMarkup('Last Refresh'));

    $properties['conditions'] = DataDefinition::create('string')
      ->setLabel(new TranslatableMarkup('Conditions'))
      ->setComputed(TRUE)
      ->setReadOnly(FALSE)
      ->setClass('\Drupal\saved_query\QuerySerialized')
      ->setSetting('source property', 'raw_conditions');

    $properties['sorts'] = DataDefinition::create('string')
      ->setComputed(TRUE)
      ->setReadOnly(FALSE)
      ->setClass('\Drupal\saved_query\QuerySerialized')
      ->setSetting('source property', 'raw_sorts');

    return $properties;
  }


  /**
   * {@inheritdoc}
   */
  public static function schema(FieldStorageDefinitionInterface $field_definition) {
    $schema = [
      'columns' => [
        'entity_type' => [
          'type' => 'varchar',
          'default' => 'node',
          'length' => 64
        ],
        'raw_conditions' => [
          'type' => 'varchar',
          'length' => 2048
        ],
        'raw_sorts' => [
          'type' => 'varchar',
          'length' => 2048
        ],
        'limit' => ['type' => 'int'],
        'interval' => ['type' => 'int'],
        'refreshed' => ['type' => 'int', 'default' => 0],
      ],
    ];

    return $schema;
  }

  /**
   * {@inheritdoc}
   */
  public function fieldSettingsForm(array $form, FormStateInterface $form_state) {
    $supported_fields = ['entity_reference', 'entity_reference_quantity', 'entity_reference_override'];
    $entity_type_id = $this->getFieldDefinition()->getTargetEntityTypeId();
    $bundle = $this->getFieldDefinition()->getTargetBundle();

    $options = []; // Get the entity reference fields attached to this bundle

    foreach (\Drupal::entityManager()->getFieldDefinitions($entity_type_id, $bundle) as $field_name => $field_definition) {
      if (!empty($field_definition->getTargetBundle())) {
        if (in_array($field_definition->getType(), $supported_fields)) {
          $options[$field_name] = $field_definition->getLabel();
        }
      }
    }

    $elements = [];
    $elements['target_field'] = [
      '#type' => 'select',
      '#title' => t('Target Field'),
      '#default_value' => $this->getSetting('target_field'),
      '#options' => $options,
      '#description' => t('The reference field this query is intended to populate.'),
      '#required' => TRUE,
    ];

    return $elements;
  }

  /**
   * {@inheritdoc}
   */
  public function isEmpty() {
    $type = $this->get('entity_type')->getValue();
    $conditions = $this->get('raw_conditions')->getValue();
    $sorts = $this->get('raw_sorts')->getValue();

    $empty = (empty($type) && empty($conditions) && empty($sorts));
    return $empty;
  }

  public function preSave() {
    parent::preSave(); // TODO: Change the autogenerated stub
    $conditions = $this->get('conditions')->getValue();
    $sorts = $this->get('sorts')->getValue();

    if (!empty($conditions) && is_array($conditions)) {
      $this->set('raw_conditions', serialize($conditions));
    }
    if (!empty($sorts) && is_array($sorts)) {
      $this->set('raw_sorts', serialize($sorts));
    }
  }

  public function postSave($update) {
    parent::postSave($update);
    if ($this->refresh_now) {
      if ($entity = $this->getParent()->getParent()->getValue()) {
        if ($name = $this->getFieldDefinition()->getFieldStorageDefinition()->getName()) {
          saved_query_update_single_entity($entity, $name);
        }
      }
    }
  }

  /**
   * Returns a ready-to-execute EntityQueryInterface instance.
   *
   * @return \Drupal\Core\Entity\Query\QueryInterface
   *   The query object that can query the given entity type.
   */
  public function getQuery() {
    $query = \Drupal::entityQuery($this->entity_type);
    $token = \Drupal::token();

    if ($limit = $this->limit) {
      $query->range(0, $limit);
    }

    foreach ($this->conditions as $key => $condition) {
      if (strtolower($key) == 'and') {
        // TODO: AndConditionGroups
      }
      elseif (strtolower($key) == 'or') {
        // TODO: OrConditionGroups
      }
      else {
        if (is_array($condition)) {
          $value = $token->replace($condition['value']);
          $operator = $condition['operator'];
        }
        else {
          $value = $token->replace($condition);
          $operator = '=';

        }

        switch (strtoupper($value)) {
          case 'IS NULL':
            $query->exists($value);
            break;
          case 'IS NOT NULL':
            $query->notExists($value);
            break;
          default:
            $query->condition($key, $value, $operator);
            break;
        }
      }
    }

    foreach ($this->sorts as $field => $direction) {
      $query->sort($field, $direction);
    }

    return $query;
  }
}
