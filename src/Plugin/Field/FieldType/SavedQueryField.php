<?php

namespace Drupal\saved_query\Plugin\Field\FieldType;

use Drupal\Component\Utility\Random;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Field\FieldItemBase;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\Core\TypedData\DataDefinition;
use Drupal\Core\Entity\Query\QueryInterface;
use Drupal\Component\Serialization\Json;

/**
 * Plugin implementation of the 'saved_query_field' field type.
 *
 * @FieldType(
 *   id = "saved_query_field",
 *   label = @Translation("Saved Query"),
 *   description = @Translation("Stores information needed to run a saved database query"),
 *   default_widget = "raw_saved_query_widget",
 *   default_formatter = "preview_saved_query_formatter"
 * )
 */
class SavedQueryField extends FieldItemBase {

  /**
   * {@inheritdoc}
   */
  public static function defaultFieldSettings() {
    return [
      'target_field' => '',
    ] + parent::defaultFieldSettings();
  }

  /**
   * {@inheritdoc}
   */
  public static function propertyDefinitions(FieldStorageDefinitionInterface $field_definition) {
    // Prevent early t() calls by using the TranslatableMarkup.
    $properties['entity_type'] = DataDefinition::create('string')
      ->setLabel(new TranslatableMarkup('Entity Type'));

    $properties['raw_sorts'] = DataDefinition::create('string')
      ->setLabel(new TranslatableMarkup('Raw Sorts'));

    $properties['raw_conditions'] = DataDefinition::create('string')
      ->setLabel(new TranslatableMarkup('Raw Conditions'));

    $properties['limit'] = DataDefinition::create('integer')
      ->setLabel(new TranslatableMarkup('Result limit'));

    $properties['interval'] = DataDefinition::create('integer')
      ->setLabel(new TranslatableMarkup('Refresh Interval'));

    $properties['refreshed'] = DataDefinition::create('integer')
      ->setLabel(new TranslatableMarkup('Last Refresh'));

    $properties['conditions'] = DataDefinition::create('string')
      ->setLabel(new TranslatableMarkup('Conditions'))
      ->setComputed(TRUE)
      ->setReadOnly(FALSE)
      ->setClass('\Drupal\saved_query\QuerySerialized')
      ->setSetting('source property', 'raw_conditions');

    $properties['sorts'] = DataDefinition::create('string')
      ->setComputed(TRUE)
      ->setReadOnly(FALSE)
      ->setClass('\Drupal\saved_query\QuerySerialized')
      ->setSetting('source property', 'raw_sorts');

    return $properties;
  }


  /**
   * {@inheritdoc}
   */
  public static function schema(FieldStorageDefinitionInterface $field_definition) {
    $schema = [
      'columns' => [
        'entity_type' => [
          'type' => 'varchar',
          'default' => 'node',
          'length' => 64
        ],
        'raw_conditions' => [
          'type' => 'text',
        ],
        'raw_sorts' => [
          'type' => 'text',
        ],
        'limit' => ['type' => 'int'],
        'interval' => ['type' => 'int'],
        'refreshed' => ['type' => 'int', 'default' => 0],
      ],
    ];

    return $schema;
  }

  /**
   * {@inheritdoc}
   */
  public function fieldSettingsForm(array $form, FormStateInterface $form_state) {
    $supported_fields = ['entity_reference', 'entity_reference_quantity', 'entity_reference_override'];
    $entity_type_id = $this->getFieldDefinition()->getTargetEntityTypeId();
    $bundle = $this->getFieldDefinition()->getTargetBundle();

    $options = []; // Get the entity reference fields attached to this bundle

    foreach (\Drupal::entityManager()->getFieldDefinitions($entity_type_id, $bundle) as $field_name => $field_definition) {
      if (!empty($field_definition->getTargetBundle())) {
        if (in_array($field_definition->getType(), $supported_fields)) {
          $options[$field_name] = $field_definition->getLabel();
        }
      }
    }

    $elements = [];
    $elements['target_field'] = [
      '#type' => 'select',
      '#title' => t('Target Field'),
      '#default_value' => $this->getSetting('target_field'),
      '#options' => $options,
      '#description' => t('The reference field this query is intended to populate.'),
      '#required' => TRUE,
    ];

    return $elements;
  }

  /**
   * {@inheritdoc}
   */
  public function isEmpty() {
    $type = $this->get('entity_type')->getValue();
    $conditions = $this->get('raw_conditions')->getValue();
    $sorts = $this->get('raw_sorts')->getValue();

    $empty = (empty($type) && empty($conditions) && empty($sorts));
    return $empty;
  }

  public function preSave() {
    parent::preSave(); // TODO: Change the autogenerated stub

    if ($this->refresh_now) {
      if ($entity = $this->getParent()->getParent()->getValue()) {
        if ($name = $this->getFieldDefinition()->getFieldStorageDefinition()->getName()) {
          saved_query_update_single_entity($entity, $name, FALSE);
        }
      }
    }
  }

  /**
   * Returns a ready-to-execute EntityQueryInterface instance.
   *
   * @return \Drupal\Core\Entity\Query\QueryInterface
   *   The query object that can query the given entity type.
   */
  public function getQuery() {
    $query = \Drupal::entityQuery($this->entity_type);

    if ($limit = $this->limit) {
      $query->range(0, $limit);
    }

    foreach ($this->conditions as $key => $condition) {
      if (strpos(strtolower($key), 'group_') === 0) {
        if ($condition['conjunction'] == 'AND') {
          $group = $query->andConditionGroup();
        }
        else {
          $group = $query->orConditionGroup();
        }

        foreach ($condition['conditions'] as $field => $grouped_condition) {
          $this->addCondition($group, $field, $grouped_condition);
        }
        $query->condition($group);
      }
      else {
        $this->addCondition($query, $key, $condition);
      }
    }

    foreach ($this->sorts as $field => $direction) {
      $query->sort($field, $direction);
    }

    return $query;
  }

  /**
   * Translates a special array format and adds it as a condition to the query.
   *
   * @param \Drupal\Core\Entity\Query\ConditionInterface|\Drupal\Core\Entity\Query\QueryInterface $query
   * @param string $field
   *  The name of the field/column the condition is for.
   * @param $condition
   */
  protected function addCondition($query, $field, $condition) {
    if (is_array($condition)) {
      $value = $condition['value'];
      $operator = $condition['operator'];
    }
    else {
      $value = $condition;
      $operator = '=';
    }

    if (is_string($value)) {
      switch (strtoupper($value)) {
        case 'IS NULL':
          $query->notExists($value);
          break;
        case 'IS NOT NULL':
          $query->exists($value);
          break;
        default:
          $query->condition($field, $value, $operator);
          break;
      }
    }
    else {
      $query->condition($field, $value, $operator);
    }
  }
}
